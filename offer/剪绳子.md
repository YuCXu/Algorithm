# 剪绳子

#### 题目：给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n>1并且m>1），每一段的长度记为k[0],k[1],...k[m]。请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 

##### 思路：①需要O(n^2)时间和O(n)空间的动态规划的思路 ；②需要O(1)时间和空间的贪婪算法 

①需要O(n^2)时间和O(n)空间的动态规划的思路

​	（1）首先定义函数f(n)把长度为n的绳子剪成若干段后各段乘积的最大值。在剪第一刀的时候，我们有n-1种选择，也就是剪出来的第一段绳子的可能长度为1，2，...，n-1。因此f(n)=max(f(i)xf(n-i))，其中0<i<n。

​	（2）这是一个从上至下的递归公式。由于递归会有很多重复的子问题，从而有大量不必要的重复计算。一个更好的办法就是按照从下往上的顺序计算，也就是先得到f(2)、f(3)，再得到f(4)、f(5)，直到得到f(n)。

​	（3）当绳子长度为2时，只可能剪成长度为1的两段，因此f(2)等于1。当绳子长度为3时，可能把绳子剪成长度为1和2的两段或者长度为1的三段，由于2x1>1x1x1，因此f(3)=2。

##### 代码实现：

```java
class Solution {
    public int maxProductAfterCutting(int length)
    {
        int max = 0;
        if(length < 2) return 0;
        if(length == 2) return 1;
        if(length == 3) return 2;
        int[] res = new int[length+1];
        res[0] = 0;
        res[1] = 1;
        res[2] = 2;
        res[3] = 3;
        for(int i = 4 ; i <= length ; i++){
            for(int j = 1 ; j <= i / 2 ; j++){
                int r = res[j] * res[i-j];
                if(max < r){
                    max = r;
                    res[i] = max;
                }
            }
        }
        max = res[length];
        return max;
    }
}
```

上述代码中，子问题的最优解存储在数组array里。数组中第i个元素表示把长度为i的绳子剪成若干段之后各段长度乘积的最大值，即f(i)。我们注意到代码中的第一个for循环变量i是顺序递增的，这意味着计算顺序是自下而上的。因此，在求f(i)之前，对于每一个j(0<i<j)而言，f(j)都已经求出来了，并且结果保存在array[i]数组中，为了求解f(i)，我们需要求出所有可能的f(j)xf(j-1)并比较得出他们的最大值。这就是代码中第二个for循环的功能。

②需要O(1)时间和空间的贪婪算法 

##### 代码实现：

```java
class Solution {
    public int maxProductAfterCutting(int length)
    {
        if(length < 2) return 0;
        if(length == 2) return 1;
        if(length == 3) return 2;
        //尽可能多的剪去长度为3的绳子
        int temp = length / 3;
        //当绳子最后剩下长度为4的时候，不能再剪去长度为3的绳子段
        //此时更好的方法就是把绳子剪成长度为2的两段，因为2x2>3x1
        if(length - temp * 3 == 1){
            temp -= 1;
        }
        //有三种情况，最后是0，1，2，3，4 (0，1，3时temp=0，pow(2,0)=1) (2，4时pow分别为2和4)
        int temp2 = (length - temp*3) / 2;
        return (int)(Math.pow(3,temp))*(int)(Math.pow(2,temp2)); //3的temp次方
    }
}
```

接下来我们证明这种思路的正确性。首先，当n>=5的时候，我们可以证明2x(n-2)>n并且3x(n-3)>n。也就是说，当绳子剩下的长度大于或者等于5的时候，我们就把它剪成长度为3或为2的绳子段。

前面证明的前提是n>=5。那么当绳子为4呢？在长度为4的绳子上剪一刀，有两种可能的结果：剪成长度为1和3的两根绳子，或者两根长度都为2的绳子。注意2x2>1x3，同时2x2=4也就是说，当长度为4时，其实没必要剪，只是题目中的要求时至少剪一刀。



